'''
[설명]
N x M
각각의 칸은 벽 또는 빈 칸
청소기는 바라보는 방향
방향은 동, 서, 남, 북
방의 각 칸은 좌표 (r, c)
(0, 0) ~ (N-1, M-1)
처음에 빈 칸은 전부 청소되지 않은 상태

- 로봇 청소기 작동
    - 현재 칸이 아직 청소되지 않은 경우
        - 현재 칸을 청소
    - 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 없는 경우
        - 바라보는 방향을 유지한 채로 한 칸 후진할 수 있다면
            - 한 칸 후진하고 처음으로 돌아간다.
        - 바라보는 방향의 뒤쪽 칸이 벽이라 후진할 수 없다면
            - 작동 멈춤
    - 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 있는 경우
        - 반시계 방향 90도 회전
        - 바라보는 방향을 기준으로 앞쪽 칸이 청소되지 않은 빈 칸인 경우
            - 한 칸 전진
        - 처음으로 돌아간다.

- 방향
    - 0인 경우 북쪽
    - 1인 경우 동쪽
    - 2인 경우 남쪽
    - 3인 경우 서쪽

- 상태
    - 0: 청소되지 않은 빈 칸
    - 1: 벽
방의 가장 북쪽, 가장 남쪽, 가장 서쪽, 가장 동쪽 줄 중 하나 이상에 위치한 모든 칸에는 벽
로봇 청소기가 있는 칸은 항상 빈 칸

[문제]
작동을 시작한 후 작동을 멈출 때까지 청소하는 칸의 개수 -> 최대 거리, 경우의 수 DFS
'''
'''
[알고리즘]
- DFS 
    - 방향
        - 0, 1, 2, 3 | 북, 동, 남, 서
        - 반시계 방향 회전
        - d = (d+3) % 4
    - '처음으로 돌아간다' = return
    - '작동 멈춤' = return
    - '한칸 전진' = DFS   
    - visited 미사용
        - 대신, arr에 flag 표기
        - 청소 flag 2 추가(빈칸 0, 벽 1) 
'''
'''
[구조]
- arr 저장
- dyx = 북, 동, 남, 서

- DFS(y, x, d)
- print(cnt)


- DFS(y, x, d):
    - if 빈칸:
        - cnt += 1
        - arr[y][x] = 청소
    - for 4방향: # 입력 d 값에 따라 순서 결정
        - nd = (d+3)%4 # 왼쪽 방향 회전
        - if 빈칸:
            - DFS(ny, nx, nd)
            - return
        - d = nd
    - nd = (d+2)%4 # 4방향 종료(빈칸 없음) 후 뒤로 진행
    - if 벽:
        return
    - DFS(ny, nx, d) # 뒤로 오기 전 방향 유지하여 DFS. 처음으로 돌아감.
'''


def DFS(y, x, d):
    global cnt
    if not arr[y][x]:
        cnt += 1 #
        arr[y][x] = 2 # 청소
    for _ in range(4): # 입력 d 값에 따라 순서 결정
        nd = (d+3)%4 # 왼쪽 방향 회전
        ny = y+dy[nd]
        nx = x+dx[nd]
        if not arr[ny][nx] # 청소 대상
            DFS(ny, nx, nd) # 새방향, 새위치에서 DFS
            return
        d = nd
    nd = (d+2)%4 # 4방향 종료 후 뒤로 진행
    ny = y+dy[nd]
    nx = x+dx[nd]
    if arr[ny][nx] == 1: # 벽
        return
    DFS(ny, nx, d) # 뒤로 오기 전 방향 유지하여 DFS


n, m = map(int, input().split())
y, x, d = list(map(int, input().split())) # 시작 위치, 방향 d
arr = [list(map(int, input().split())) for _ in range(n)]
dy = [-1, 0, 1, 0]
dx = [0, 1, 0, -1]
cnt = 0

DFS(y, x, d)
print(cnt)