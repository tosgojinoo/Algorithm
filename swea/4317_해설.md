- 필요 영역: 개당 2*2
- 영역은 1 단위로 구성
- 중간에 사용 불가능 영역 발생, 회색
- 여러 방법 존재
- 최대 생산 가능 칩 개수
- 웨이퍼 세로길이 H, 가로길이 W, 직사각형(정사각형 포함)
- 5 <= H <= 10
- 5 <= W <= 25
- 칩 생산 가능 영역 0, 불가 영역 1


[main]
1. map 정보 입력 -> wafer
2. memory 생성
    - 2^H 만 큼 생성
    - 한 열만 확인 했을 때, 전체 형태를 대상으로 경우의 수를 확인하면
    - 2^H 개수만큼 있고, 
    - 이는 bit 경우의 수와 동일함
    - mem = [[- 1] * W for _ in range(1 << H)]
3. answer 생성 (초기값 0)
4. dfs(0, 0, 0) 실행
    - dfs(y, x, num_of_chip)

[dfs]
- dfs(y, x, num_of_chip)
- num_of_chip은 level_now 와 동일
1. global answer
2. if, y 가 H-1 이상일 때
    - map 밖으로 나갔을 때, 
    - x_0 번 열부터 시작해서 모든 열을 한 열로 붙여서 생각
    1) y는 0으로 원복, x는 한칸 증가
        - y, x = 0, x + 1
3. if, x 가 W-1와 같을 때
    - map 마지막 열에 위치할 때,
    - point 기준으로 4방을 확인하므로, 
    - 확인 제외, 종료 해야함
    1) if, answer와 현재 num_of_chip을 비교
        - 큰 것 answer에 저장
    2) return
4. if, y = 0
    - 열의 새로운 시작일 때,
    - 더 진행할 것인지 확인 (중간 종료점)
    - 열 전체의 모습을 확인하며, memory에서 검사
    - memory의 행은 bit로 변환했을 때 값, 열은 동일
    - memory상 동일 상태의 이전 num_of_chip보다 작을 경우 더이상 진행하지 않음
    1) bit 계산
        - 위치한 열 전체의 표기 값을 bit로 변환
        - bit = sum(1 << i for i in range(H) if wafer[i][x] == 1)
    2-1) mem의 bit 값에 해당하는 행, y가 위치한 열 확인
    2-2) 2-1)의 위치 값 보다 현재 chip 개수가 크면 저장
        - 아니면, return
5. if, 생산 가능 여부 확인
    - if is_valid_chip(y, x)
    1) 가능하면, 생산
        - make_chip(y, x, 1)
    2) dfs 호출
        - 생산범위 고려 2칸 이동
        - dfs(y + 2, x, num_of_chip + 1)
    3) 원래값으로 원복
        - make_chip(y, x, 0)
6. dfs 호출
    - dfs(y + 1, x, num_of_chip)
7. return

[is_valid_chip]
- is_valid_chip(y, x)
1. global wafer
2. (y,x) 기준 4방향 검사 결과
3. return 
    - 0일 경우 True
    - 1일 경우 False

[make_chip]
- make_chip(y, x, val):
1. global wafer
2. (y, x) 기준 4방향에 대해 val 값 입력
3. return


