[global]
1. 이동은 4방향만 가능
    - 방향에 대한 묶음 리스트 생성
    - directs = [[0,1],[1,0],[0,-1],[-1,0]]
    - 오른쪽, 아래, 왼쪽, 위 (시계방향)

[main]
1. answer 최대값 N*N 설정
    - 최대 모든 N x N 칸 이동의 경우
2. 각 칸에 대한 pipe 정보 저장
    - 시작과 끝이 N x N 밖에 위치 하므로,
    - 좌, 우측에 [0]을 한줄씩 추가 설정
3. map[N-1][N+1], map[0][0] = 1, 1
    - 시작과 끝을 1로 초기값 설정
4. 방향에 대한 memory 리스트 생성
    - 종료까지 지속적으로 기억
    - 4방향 각각에 대한 표기
    - 각각은 최대 25번째에 방문하는 것으로 초기값 설정
    - mem = [[[N*N]*(N+2) for _ in range(N)] for _ in range(len(directs))]
5. vistied 리스트 생성
    - backtracking 후 원복
    - 초기값 0 설정
    - vistied = [[0]*(N+2) for _ in range(N)]
6. recur 함수 실행
    - recur(point, endpoint, direction, move)
7. 4~6 과정을 2회 실행 및 결과 저장
    - visited, mem 생성
    - (0,0) -> (N-1, N+1) 과정. direction 0, move 1
    - (N-1, N+1) -> (0,0) 과정. direction 2, move 1
    - 결과 각각 저장
8. 두 결과의 최소값 출력

[recur]
1. global answer 변수 선언
2. if, point == endpoint면,
    1) answer와 move-2(총 이동거리 중 in/out 이동거리 제외) 중 최소값 저장
    2) return
3. if, 종료 조건
    1) out of map
        - point_x<0 또는 point_y<0 또는 point_y>N-1 또는 point_x>N+1
    2) or, 이미 계산된 이동값 보다 현 이동값이 높음
        - answer < move
    3) or, direction 저장값 보다 현 이동값이 높음
        - '이전에 왔었다, 방향도 바꿨었다'를 의미
        - mem[direction][point_y][point_x] 가 move 보다 큼
    4) or, 이미 방문 함
        - (visited[point[0]][point[1]]==1)
    5) or, pipe가 없음
        - (pipemap[point[0]][point[1]] == 0)
    6) return
4. pipe 정보 받아오기
    - pipe = pipemap[point[0]][point[1]]
5. 현 이동거리 정보를 mem 저장
    - mem[direction][point[0]][point[1]] = move
6. 현 위치 visited에 저장
    - visited[point[0]][point[1]] = 1
7-1. if, pipe가 직선일 경우
    - pipe는 크게 두부류, 직선(회전하면 동일) or 90도(4방향은 결국 동일 파이프)
    - pipe 번호 1,2는 직선
    - pipe < 3
    1) directions에서 dy, dx 가져옴
    2) recur 함수 호출
        - recur((point[0]+dy, point[1]+dx), endpoint, direction, move+1)
7-2. else,
    - 90도 파이프의 경우, 방향 전환이 90도
    - 현 direction 에서 하나 뒤 또는 앞의 방향으로 전환하면 됨
    1) for, i 는 1 or -1
        a. 새 방향은 현 방향에서 앞 or 뒤 전환 
            - ndirection = (direction + i +4) % 4
        b. directions 에서 변량 가져옴 
            - dy, dx = directions[ndirection]
        c. recur 함수 호출
            - recur((point[0]+dy, point[1]+dx), endpoint, ndirection, move+1)

7-3. 방문 정보 초기화
    - visited[point[0]][point[1]] = 0