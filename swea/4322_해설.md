Main
1. N(packet 개수) 입력
2. packets(packet 전체 정보(T_in, T_len)) 입력
3. answer = -1
4. cpu 개수를 1~5까지 증가 시킨다. (문제 제한, cpu 5개, for cpu_num in range(5))
    1) cpu_height 를 cpu 개수 만큼 생성
        - cpu 각각 종료 시간 기록
        - 초기값 0
    2) delay 를 cpu 개수 만큼 생성
        - T_in이 cpu_height[] 보다 빠를 경우(작을 경우) 발생
        - 초기값 0
    3) visit = {}
    4) DFS(packet_idx == 0) 실행
    5) if DFS == True
        a. answer 저장
            - cpu_num + 1


DFS(packet_idx)
1. packet_idx 가 packets 전체 개수와 동일하면 종료
    - 이미 packets 범위 초과
    - return True
2. packet = packets[packet_idx]   
3. cpu를 처음 부터 각각 확인
    1) if cpu_height[i] > packet[0]
        - i번째 cpu의 종료 시간이 packet 입력 시간보다 늦을 경우 == 대기 필요시
        a. delay[i]에 대기시간 입력
            - cpu_height[i] - packet[0]
4. rep (참조값) 생성
    - tuple([packet_idx] + sorted(delay)) == tuple(packet_idx, new_delay[0], ..., new_delay[n])
    - packet_idx와 대기시간열의 오름차순 정렬로 함께 구성
5. visit dict 내에 rep가 있는지 확인 
    - 동일 상황 있었는지 확인
    1) 있으면, 종료, return False
6. visit dict에 {rep:1} 저장
7. cpu 개수만큼 루프
    1) old_cpu_height = cpu_height[i]
        - cpu[i] 의 종료 초기값 저장
    2) if, 대기시간이 필요한 경우 (0보다 큰 경우)
        a. if, 대기시간에 packet 종료시간을 더한 값이 10(문제의 제한 종료 시간) 이하일 경우
            a) cpu_height[i](cpu 종료시간)에 [현재 cpu 종료시간 + packet 종료시간] 기록
        b. 대기 필요한데, 제한 종료시간 넘을 경우, 루프 종료
    3) else, 대기 필요 없는 경우 
        a. cpu_height[i](cpu 종료시간)에 [T_in + T_len] 저장
            - (참고) cpu_height는 끝 시간만 필요
            - 이전 cpu_height(종료시간)과 packet 시작 시간의 차이를 고려할 필요 없음
    4) 다음 packet에 대해 분석
        - if, DFS(packet_idx+1): return True
    5) 앞에서 처리되지 않았다면, 원복
        - cpu_height[i] = old_cpu_height
8. 앞에서 처리되지 않았다면, 종료
    return False